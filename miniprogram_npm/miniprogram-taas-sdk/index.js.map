{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const sm2 = require('sm-crypto').sm2;\n\nconst addresses = ['https://node0.taas.internetapi.cn'];\n\n// ServerAddr GetServerAddr()\n/**\n * Get TaaS backend server address.\n *\n * @return an address of a TaaS backend server. If there are multiple available servers, return a random one.\n */\nfunction getServerAddr() {\n    if (addresses.length === 1) {\n        return addresses[0];\n    }\n    return addresses[Math.floor(Math.random() * addresses.length)];\n};\n\n// AccessToken register(InvitationCode, ServerAddr, Cred)\n/**\n * Register with invitation code and public key, get the access token.\n *\n * @param invitationCode    the invitation code\n * @param serverAddr        the server address\n * @param credential        an object that is returned by sdk.getCredential()\n * @param callback          a function called when the server has responded the sdk.register request.\n * @return null.\n */\nfunction register(invitationCode, serverAddr, credential, callback){\n    var url = serverAddr;\n    if (!url) url = getServerAddr();\n    url = url + \"/auth/register\";\n\n    var formData = {\n        from: credential.publicKey,\n        verifyCode: invitationCode\n    };\n\n    var params = {\n        url: url,\n        method: \"POST\",\n        timeout: 0,\n        header: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        data: formData\n    };\n    params.success = (res) => {\n        if (res.data.code !== 0){\n            callback(new Error(res.data.message));\n            return ;\n        }\n\n        var token = res.data.data.accessToken;\n        callback(undefined, token);\n    };\n    params.fail = (res) => {callback(new Error(\"network error\"));};\n    wx.request(params);\n};\n\n// Cred GetCredential()\n/**\n * Generate a public key, private key and credential, i.e. access token\n *\n * @return null.\n */\nfunction getCredential(invitationCode, serverAddr, callback) {\n    let cred = sm2.generateKeyPairHex();\n    \n    register(invitationCode, serverAddr, cred, (err, data) => {\n        if (err) callback(err);\n        var r = {\n            publicKey: cred.publicKey,\n            privateKey: cred.privateKey,\n            credential: data\n        };\n        callback(undefined, r);\n    });\n};\n\n/**\n * Get the signature of given message by a private key.\n *\n * @param text the message to make signature\n * @param credential a public key and private key pair\n * @return the signature of given message.\n */\nfunction signature(text, credential) {\n    return sm2.doSignature(text, credential.privateKey);\n};\n\n// HashID StoreEvidence(Data, ServerAddr, Cred)\n/**\n * Store evidence of the data in the TaaS backend.\n *\n * @param data          the message to be stored\n * @param serverAddr    the server address\n * @param credential    an object that is returned by sdk.getCredential()\n * @param callback      a function called when the server has responded the sdk.storeEvidence request.\n * @return null.\n */\nfunction storeEvidence(data, serverAddr, credential, callback){\n    var text, path;\n    if (typeof data === \"object\"){\n        text = data.text;\n        path = data.path;\n    } else if (typeof data === \"string\"){\n        text = data;\n    } else {\n        throw new Error(`unidentified type of data: ${typeof data}`);\n    };\n\n    if (!path && !text)\n        throw new Error(\"no data to store\");\n    if (!credential)\n        throw new Error(\"no credential\");\n    if (!callback)\n        throw new Error(\"no callback\");\n    \n    var sig;\n    if (text){\n        sig = signature(text, credential);\n    } else {\n        sig = signature(path, credential);\n    }\n\n    var url = serverAddr;\n    if (!url) url = getServerAddr();\n\n    if (!path){\n        url = url + \"/uploadMessage\";\n        var formData = {\n            from: credential.publicKey,\n            data: text,\n            sig: sig,\n            accessToken: credential.credential\n        };\n\n        var params = {\n            url: url,\n            method: \"POST\",\n            timeout: 0,\n            header: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\n            },\n            data: formData\n        };\n        \n        params.success = (res) => {\n            if (res.data.code !== 0){\n                callback(new Error(res.data.message));\n                return ;\n            }\n            callback(undefined, res.data.data);\n        };\n        params.fail = () => {callback(new Error(\"network error\"));};\n        wx.request(params);\n    } else {\n        url = url + \"/uploadFile\";\n        var formData = {\n            from: credential.publicKey,\n            sig: sig,\n            accessToken: credential.credential\n        };\n        if (text) formData.text = text;\n\n        var params = {\n            url: url,\n            method: 'POST',\n            name: \"data\",\n            filePath: path,\n            header: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            formData: formData\n        };\n        params.success = (res) => {\n            var data = JSON.parse(res.data);\n            if (data.code !== 0){\n                callback(new Error(data.message));\n                return ;\n            }\n            callback(undefined, data.data);\n        };\n        params.fail = () => {callback(new Error(\"network error\"));};\n        wx.uploadFile(params);\n    };\n};\n\n// Data QueryEvidence(HashID, ServerAddr, Cred)\n/**\n * Query the data according to a hash ID.\n *\n * @param hashID        the hash value to be queried\n * @param serverAddr    the server address\n * @param credential    an object that is returned by sdk.getCredential()\n * @param callback      a function called when the server has responded the sdk.queryEvidence request.\n * @return null.\n */\n function queryEvidence(hashId, serverAddr, credential, callback){\n    if (!callback)\n        throw new Error(\"no callback\");\n    \n    var url = serverAddr;\n    if (!url) url = getServerAddr();\n    url = url + \"/queryData\";\n\n    var params = {\n        url: url,\n        method: \"POST\",\n        timeout: 0,\n        header: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        data: {\n            hash: hashId,\n            from: credential.publicKey,\n            accessToken: credential.credential\n        }\n    };\n\n    params.success = (res) => {\n        if (res.data.code !== 0){\n            callback(new Error(res.data.message));\n            return ;\n        }\n        var data = res.data.data;\n        var d = data.data;\n        if (!d.type || d.type === \"text\"){\n            d.text = d.data;\n            delete d.data;\n        };\n        callback(undefined, data);\n    };\n    params.fail = () => {\n        callback(new Error(\"network error\"));\n    };\n    wx.request(params);\n};\n\n/**\n * List current smart contract list of given user access token and server address.\n *\n * @param serverAddr    the server address\n * @param credential    an object that is returned by sdk.getCredential()\n * @param callback      a function called when the server has responded the sdk.getContractList request.\n * @return null.\n */\nfunction getContractList(serverAddr, credential, callback) {\n    if (!serverAddr) serverAddr = getServerAddr();\n    const url = `${serverAddr}/contract/listContractProcess`;\n    \n    wx.request({\n        url: url,\n        method: \"POST\",\n        header: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        data: {\n            from: credential.publicKey,\n            accessToken: credential.credential\n        },\n        success: function(res) {\n            if (res.data.code !== 0){\n                callback(new Error(res.data.message));\n                return ;\n            }\n            callback(undefined, res.data.data);\n        },\n        fail: function(res) {\n            callback(new Error(\"network error\"));\n        }\n    });\n};\n\n/**\n * Execute a smart contract by given contract ID and action\n *\n * @param contractInfo  an object containing contract ID and contract action to execute\n * @param serverAddr    the server address\n * @param credential    an object that is returned by sdk.getCredential()\n * @param callback      a function called when the server has responded the sdk.getContractList request.\n * @return null.\n */\nfunction executeContract(contractInfo, serverAddr, credential, callback) {\n    if (!serverAddr) serverAddr = getServerAddr();\n    var url = `${serverAddr}/contract/executeContract`;\n    var data = {\n        from: credential.publicKey,\n        accessToken: credential.credential,\n        contractID: contractInfo.id,\n        operation: contractInfo.method,\n        arg: contractInfo.arg\n    };\n    \n    wx.request({\n        url: url,\n        method: \"POST\",\n        data: data,\n        header: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        success: function(res) {\n            if (res.data.code !== 0){\n                callback(new Error(res.data.message));\n                return ;\n            }\n            callback(undefined, res.data.data);\n        },\n        fail: function(res) {\n            callback(new Error(\"network error\"));\n        }\n    });\n};\n\nfunction promisify(func){\n    function wrapped_func(){\n        const args = arguments;\n        return new Promise((resolve, reject) => {\n            func(...args, (err, data) => {\n                if (err) reject(err);\n                resolve(data);\n            });\n        });\n    };\n    return wrapped_func;\n};\n\nconst getCredentialP = promisify(getCredential);\nconst storeEvidenceP = promisify(storeEvidence);\nconst queryEvidenceP = promisify(queryEvidence);\nconst getContractListP = promisify(getContractList);\nconst executeContractP = promisify(executeContract);\n\nmodule.exports = {\n    version: \"1.4.2\",\n    getServerAddr: getServerAddr,\n    getCredential: getCredential,\n    storeEvidence: storeEvidence,\n    queryEvidence: queryEvidence,\n    getContractList: getContractList,\n    executeContract: executeContract,\n    promises: {\n        getServerAddr: getServerAddr,\n        getCredential: getCredentialP,\n        storeEvidence: storeEvidenceP,\n        queryEvidence: queryEvidenceP,\n        getContractList: getContractListP,\n        executeContract: executeContractP\n    }\n};\n"]}