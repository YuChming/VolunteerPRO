{"version":3,"sources":["index.js","src/sm2/index.js","src/sm2/asn1.js","src/sm2/sm3.js","src/sm2/utils.js","src/sm2/ec.js","src/sm2/sm2.js","src/sm3/index.js","src/sm4/index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AKfA,AHSA,ACHA;AFOA,AGTA,AJYA,AKfA,AHSA,ACHA;AFOA,AGTA,AJYA,AKfA,AHSA,ACHA;AFOA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA;ALgBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA;ALgBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA;ALgBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AKfA,AHSA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,ACHA,AGTA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA,ACHA;ANmBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AJYA,AENA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;ALgBA,AGTA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA,AIZA;AFOA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = {\n    sm2: require('./src/sm2/index'),\n    sm3: require('./src/sm3/index'),\n    sm4: require('./src/sm4/index'),\n};\n","const { BigInteger } = require('jsbn');\nconst { encodeDer, decodeDer } = require('./asn1');\nconst SM3Digest = require('./sm3');\nconst SM2Cipher = require('./sm2');\nconst _ = require('./utils');\n\nlet { G, curve, n } = _.generateEcparam();\nconst C1C2C3 = 0;\n\n/**\n * 加密\n */\nfunction doEncrypt(msg, publicKey, cipherMode = 1) {\n    let cipher = new SM2Cipher();\n    msg = _.hexToArray(_.parseUtf8StringToHex(msg));\n\n    if (publicKey.length > 128) {\n      publicKey = publicKey.substr(publicKey.length - 128);\n    }\n    let xHex = publicKey.substr(0, 64);\n    let yHex = publicKey.substr(64);\n    publicKey = cipher.createPoint(xHex, yHex);\n\n    let c1 = cipher.initEncipher(publicKey);\n\n    cipher.encryptBlock(msg);\n    let c2 = _.arrayToHex(msg);\n\n    let c3 = new Array(32);\n    cipher.doFinal(c3)\n    c3 = _.arrayToHex(c3);\n\n    return cipherMode === C1C2C3 ? c1 + c2 + c3 : c1 + c3 + c2;\n}\n\n/**\n * 解密\n */\nfunction doDecrypt(encryptData, privateKey, cipherMode = 1) {\n    let cipher = new SM2Cipher();\n\n    privateKey = new BigInteger(privateKey, 16);\n\n    let c1X = encryptData.substr(0, 64);\n    let c1Y = encryptData.substr(0 + c1X.length, 64);\n    let c1Length = c1X.length + c1Y.length;\n\n    let c3 = encryptData.substr(c1Length, 64);\n    let c2 = encryptData.substr(c1Length + 64);\n\n    if (cipherMode === C1C2C3) {\n        c3 = encryptData.substr(encryptData.length - 64);\n        c2 = encryptData.substr(c1Length, encryptData.length - c1Length - 64);\n    }\n\n    let data = _.hexToArray(c2);\n\n    let c1 = cipher.createPoint(c1X, c1Y);\n    cipher.initDecipher(privateKey, c1);\n    cipher.decryptBlock(data);\n    let c3_ = new Array(32);\n    cipher.doFinal(c3_);\n\n    let isDecrypt = _.arrayToHex(c3_) === c3;\n\n    if (isDecrypt) {\n        let decryptData = _.arrayToUtf8(data);\n        return decryptData;\n    } else {\n        return '';\n    }\n}\n\n/**\n * 签名\n */\nfunction doSignature(msg, privateKey, { pointPool, der, hash, publicKey } = {}) {\n    let hashHex = typeof msg === 'string' ? _.parseUtf8StringToHex(msg) : _.parseArrayBufferToHex(msg);\n\n    if (hash) {\n        // sm3杂凑\n        publicKey = publicKey || getPublicKeyFromPrivateKey(privateKey);\n        hashHex = doSm3Hash(hashHex, publicKey);\n    }\n\n    let dA = new BigInteger(privateKey, 16);\n    let e = new BigInteger(hashHex, 16);\n\n    // k\n    let k = null;\n    let r = null;\n    let s = null;\n\n    do {\n        do {\n            let point;\n            if (pointPool && pointPool.length) {\n                point = pointPool.pop();\n            } else {\n                point = getPoint();\n            }\n            k = point.k;\n\n            // r = (e + x1) mod n\n            r = e.add(point.x1).mod(n);\n        } while (r.equals(BigInteger.ZERO) || r.add(k).equals(n));\n\n        // s = ((1 + dA)^-1 * (k - r * dA)) mod n\n        s = dA.add(BigInteger.ONE).modInverse(n).multiply(k.subtract(r.multiply(dA))).mod(n);\n    } while (s.equals(BigInteger.ZERO));\n\n    if (der) {\n        // asn1 der编码\n        return encodeDer(r, s);\n    }\n\n    return _.leftPad(r.toString(16), 64) + _.leftPad(s.toString(16), 64);\n}\n\n/**\n * 验签\n */\nfunction doVerifySignature(msg, signHex, publicKey, { der, hash } = {}) {\n    let hashHex = typeof msg === 'string' ? _.parseUtf8StringToHex(msg) : _.parseArrayBufferToHex(msg);\n\n    if (hash) {\n        // sm3杂凑\n        hashHex = doSm3Hash(hashHex, publicKey);\n    }\n\n    let r, s;\n    if (der) {\n        let decodeDerObj = decodeDer(signHex);\n        r = decodeDerObj.r;\n        s = decodeDerObj.s;\n    } else {\n        r = new BigInteger(signHex.substring(0, 64), 16);\n        s = new BigInteger(signHex.substring(64), 16);\n    }\n\n    let PA = curve.decodePointHex(publicKey);\n    let e = new BigInteger(hashHex, 16);\n\n    // t = (r + s) mod n\n    let t = r.add(s).mod(n);\n\n    if (t.equals(BigInteger.ZERO)) return false;\n\n    // x1y1 = s * G + t * PA\n    let x1y1 = G.multiply(s).add(PA.multiply(t));\n\n    // R = (e + x1) mod n\n    let R = e.add(x1y1.getX().toBigInteger()).mod(n);\n\n    return r.equals(R);\n}\n\n/**\n * sm3杂凑算法\n */\nfunction doSm3Hash(hashHex, publicKey) {\n    let smDigest = new SM3Digest();\n    \n    let z = new SM3Digest().getZ(G, publicKey.substr(2, 128));\n    let zValue = _.hexToArray(_.arrayToHex(z).toString());\n    \n    let p = hashHex;\n    let pValue = _.hexToArray(p);\n    \n    let hashData = new Array(smDigest.getDigestSize());\n    smDigest.blockUpdate(zValue, 0, zValue.length);\n    smDigest.blockUpdate(pValue, 0, pValue.length);\n    smDigest.doFinal(hashData, 0);\n\n    return _.arrayToHex(hashData).toString();\n}\n\n/**\n * 计算公钥\n */\nfunction getPublicKeyFromPrivateKey(privateKey) {\n    let PA = G.multiply(new BigInteger(privateKey, 16));\n    let x = _.leftPad(PA.getX().toBigInteger().toString(16), 64);\n    let y = _.leftPad(PA.getY().toBigInteger().toString(16), 64);\n    return '04' + x + y;\n}\n\n/**\n * 获取椭圆曲线点\n */\nfunction getPoint() {\n    let keypair = _.generateKeyPairHex();\n    let PA = curve.decodePointHex(keypair.publicKey);\n\n    keypair.k = new BigInteger(keypair.privateKey, 16);\n    keypair.x1 = PA.getX().toBigInteger();\n\n    return keypair;\n};\n\nmodule.exports = {\n    generateKeyPairHex: _.generateKeyPairHex,\n    doEncrypt,\n    doDecrypt,\n    doSignature,\n    doVerifySignature,\n    getPoint,\n};\n","const { BigInteger } = require('jsbn');\r\n\r\nfunction bigIntToMinTwosComplementsHex(bigIntegerValue) {\r\n    let h = bigIntegerValue.toString(16);\r\n    if (h.substr(0, 1) !== '-') {\r\n        if (h.length % 2 === 1) {\r\n            h = '0' + h;\r\n        } else if (!h.match(/^[0-7]/)) {\r\n            h = '00' + h;\r\n        }\r\n    } else {\r\n        let hPos = h.substr(1);\r\n        let xorLen = hPos.length;\r\n        if (xorLen % 2 === 1) {\r\n            xorLen += 1;\r\n        } else if (!h.match(/^[0-7]/)) {\r\n            xorLen += 2;\r\n        }\r\n        let hMask = '';\r\n        for (let i = 0; i < xorLen; i++) {\r\n            hMask += 'f';\r\n        }\r\n        let biMask = new BigInteger(hMask, 16);\r\n        let biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);\r\n        h = biNeg.toString(16).replace(/^-/, '');\r\n    }\r\n    return h;\r\n}\r\n \r\n/**\r\n * base class for ASN.1 DER encoder object\r\n */\r\nclass ASN1Object {\r\n    constructor() {\r\n        this.isModified = true;\r\n        this.hTLV = null;\r\n        this.hT = '00';\r\n        this.hL = '00';\r\n        this.hV = '';\r\n    }\r\n \r\n    /**\r\n     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)\r\n     */\r\n    getLengthHexFromValue() {\r\n        let n = this.hV.length / 2;\r\n        let hN = n.toString(16);\r\n        if (hN.length % 2 == 1) {\r\n            hN = '0' + hN;\r\n        }\r\n        if (n < 128) {\r\n            return hN;\r\n        } else {\r\n            let hNlen = hN.length / 2;\r\n            let head = 128 + hNlen;\r\n            return head.toString(16) + hN;\r\n        }\r\n    }\r\n \r\n    /**\r\n     * get hexadecimal string of ASN.1 TLV bytes\r\n     */\r\n    getEncodedHex() {\r\n        if (this.hTLV == null || this.isModified) {\r\n            this.hV = this.getFreshValueHex();\r\n            this.hL = this.getLengthHexFromValue();\r\n            this.hTLV = this.hT + this.hL + this.hV;\r\n            this.isModified = false;\r\n        }\r\n        return this.hTLV;\r\n    }\r\n \r\n    getFreshValueHex() {\r\n        return '';\r\n    }\r\n};\r\n \r\n/**\r\n * class for ASN.1 DER Integer\r\n */\r\nclass DERInteger extends ASN1Object {\r\n    constructor(options) {\r\n        super();\r\n\r\n        this.hT = '02';\r\n        if (options && options.bigint) {\r\n            this.hTLV = null;\r\n            this.isModified = true;\r\n            this.hV = bigIntToMinTwosComplementsHex(options.bigint);\r\n        }\r\n    }\r\n \r\n    getFreshValueHex() {\r\n        return this.hV;\r\n    }\r\n}\r\n\r\n/**\r\n * class for ASN.1 DER Sequence\r\n */\r\nclass DERSequence extends ASN1Object {\r\n\r\n    constructor(options) {\r\n        super();\r\n     \r\n        this.hT = '30';\r\n        this.asn1Array = [];\r\n        if (options && options.array) {\r\n            this.asn1Array = options.array;\r\n        }\r\n    }\r\n\r\n    getFreshValueHex() {\r\n        let h = '';\r\n        for (let i = 0; i < this.asn1Array.length; i++) {\r\n            let asn1Obj = this.asn1Array[i];\r\n            h += asn1Obj.getEncodedHex();\r\n        }\r\n        this.hV = h;\r\n        return this.hV;\r\n    }\r\n}\r\n\r\n/**\r\n * get byte length for ASN.1 L(length) bytes\r\n */\r\nfunction getByteLengthOfL(s, pos) {\r\n    if (s.substring(pos + 2, pos + 3) !== '8') return 1;\r\n    let i = parseInt(s.substring(pos + 3, pos + 4));\r\n    if (i === 0) return -1; // length octet '80' indefinite length\r\n    if (0 < i && i < 10) return i + 1;  // including '8?' octet;\r\n    return -2; // malformed format\r\n}\r\n\r\n/**\r\n * get hexadecimal string for ASN.1 L(length) bytes\r\n */\r\nfunction getHexOfL(s, pos) {\r\n    let len = getByteLengthOfL(s, pos);\r\n    if (len < 1) return '';\r\n    return s.substring(pos + 2, pos + 2 + len * 2);\r\n}\r\n\r\n/**\r\n * get integer value of ASN.1 length for ASN.1 data\r\n */\r\nfunction getIntOfL(s, pos) {\r\n    let hLength = getHexOfL(s, pos);\r\n    if (hLength === '') return -1;\r\n    let bi;\r\n    if (parseInt(hLength.substring(0, 1)) < 8) {\r\n        bi = new BigInteger(hLength, 16);\r\n    } else {\r\n        bi = new BigInteger(hLength.substring(2), 16);\r\n    }\r\n    return bi.intValue();\r\n}\r\n\r\n/**\r\n * get ASN.1 value starting string position for ASN.1 object refered by index 'idx'.\r\n */\r\nfunction getStartPosOfV(s, pos) {\r\n    let lLen = getByteLengthOfL(s, pos);\r\n    if (lLen < 0) return l_len;\r\n    return pos + (lLen + 1) * 2;\r\n}\r\n\r\n/**\r\n * get hexadecimal string of ASN.1 V(value)\r\n */\r\nfunction getHexOfV(s, pos) {\r\n    let pos1 = getStartPosOfV(s, pos);\r\n    let len = getIntOfL(s, pos);\r\n    return s.substring(pos1, pos1 + len * 2);\r\n}\r\n\r\n/**\r\n * get next sibling starting index for ASN.1 object string\r\n */\r\nfunction getPosOfNextSibling(s, pos) {\r\n    let pos1 = getStartPosOfV(s, pos);\r\n    let len = getIntOfL(s, pos);\r\n    return pos1 + len * 2;\r\n}\r\n\r\n/**\r\n * get array of indexes of child ASN.1 objects\r\n */\r\nfunction getPosArrayOfChildren(h, pos) {\r\n    let a = [];\r\n    let p0 = getStartPosOfV(h, pos);\r\n    a.push(p0);\r\n\r\n    let len = getIntOfL(h, pos);\r\n    let p = p0;\r\n    let k = 0;\r\n    while (1) {\r\n        var pNext = getPosOfNextSibling(h, p);\r\n        if (pNext === null || (pNext - p0  >= (len * 2))) break;\r\n        if (k >= 200) break;\r\n        \r\n        a.push(pNext);\r\n        p = pNext;\r\n        \r\n        k++;\r\n    }\r\n\r\n    return a;\r\n}\r\n\r\nmodule.exports = {\r\n    /**\r\n     * ASN.1 DER编码\r\n     */\r\n    encodeDer(r, s) {\r\n        let derR = new DERInteger({ bigint: r });\r\n        let derS = new DERInteger({ bigint: s });\r\n        let derSeq = new DERSequence({ array: [derR, derS] });\r\n\r\n        return derSeq.getEncodedHex();\r\n    },\r\n\r\n    /**\r\n     * 解析 ASN.1 DER\r\n     */\r\n    decodeDer(input) {\r\n        // 1. Items of ASN.1 Sequence Check\r\n        let a = getPosArrayOfChildren(input, 0);\r\n        \r\n        // 2. Integer check\r\n        let iTLV1 = a[0];\r\n        let iTLV2 = a[1];\r\n\r\n        // 3. getting value\r\n        let hR = getHexOfV(input, iTLV1);\r\n        let hS = getHexOfV(input, iTLV2);\r\n\r\n        let r = new BigInteger(hR, 16);\r\n        let s = new BigInteger(hS, 16);\r\n        \r\n        return { r, s };\r\n    }\r\n};\r\n","const { BigInteger } = require('jsbn');\r\nconst _ = require('./utils');\r\n\r\nlet copyArray = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n    for (let i = 0; i < length; i++) destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n};\r\n\r\nconst Int32 = {\r\n    minValue: -parseInt('10000000000000000000000000000000', 2),\r\n    maxValue: parseInt('1111111111111111111111111111111', 2),\r\n    parse: function (n) {\r\n        if (n < this.minValue) {\r\n            let bigInteger = new Number(-n);\r\n            let bigIntegerRadix = bigInteger.toString(2);\r\n            let subBigIntegerRadix = bigIntegerRadix.substr(bigIntegerRadix.length - 31, 31);\r\n            let reBigIntegerRadix = '';\r\n            for (let i = 0; i < subBigIntegerRadix.length; i++) {\r\n                let subBigIntegerRadixItem = subBigIntegerRadix.substr(i, 1);\r\n                reBigIntegerRadix += subBigIntegerRadixItem == '0' ? '1' : '0'\r\n            }\r\n            let result = parseInt(reBigIntegerRadix, 2);\r\n            return (result + 1)\r\n        } else if (n > this.maxValue) {\r\n            let bigInteger = Number(n);\r\n            let bigIntegerRadix = bigInteger.toString(2);\r\n            let subBigIntegerRadix = bigIntegerRadix.substr(bigIntegerRadix.length - 31, 31);\r\n            let reBigIntegerRadix = '';\r\n            for (let i = 0; i < subBigIntegerRadix.length; i++) {\r\n                let subBigIntegerRadixItem = subBigIntegerRadix.substr(i, 1);\r\n                reBigIntegerRadix += subBigIntegerRadixItem == '0' ? '1' : '0'\r\n            }\r\n            let result = parseInt(reBigIntegerRadix, 2);\r\n            return -(result + 1)\r\n        } else {\r\n            return n\r\n        }\r\n    },\r\n    parseByte: function (n) {\r\n        if (n < 0) {\r\n            let bigInteger = new Number(-n);\r\n            let bigIntegerRadix = bigInteger.toString(2);\r\n            let subBigIntegerRadix = bigIntegerRadix.substr(bigIntegerRadix.length - 8, 8);\r\n            let reBigIntegerRadix = '';\r\n            for (let i = 0; i < subBigIntegerRadix.length; i++) {\r\n                let subBigIntegerRadixItem = subBigIntegerRadix.substr(i, 1);\r\n                reBigIntegerRadix += subBigIntegerRadixItem == '0' ? '1' : '0'\r\n            }\r\n            let result = parseInt(reBigIntegerRadix, 2);\r\n            return (result + 1)\r\n        } else if (n > 255) {\r\n            let bigInteger = Number(n);\r\n            let bigIntegerRadix = bigInteger.toString(2);\r\n            return parseInt(bigIntegerRadix.substr(bigIntegerRadix.length - 8, 8), 2)\r\n        } else {\r\n            return n\r\n        }\r\n    }\r\n};\r\n\r\nclass SM3Digest {\r\n    constructor() {\r\n        this.xBuf = new Array();\r\n        this.xBufOff = 0;\r\n        this.byteCount = 0;\r\n        this.DIGEST_LENGTH = 32;\r\n        this.v0 = [0x7380166f, 0x4914b2b9, 0x172442d7, 0xda8a0600, 0xa96f30bc, 0x163138aa, 0xe38dee4d, 0xb0fb0e4e];\r\n        this.v0 = [0x7380166f, 0x4914b2b9, 0x172442d7, -628488704, -1452330820, 0x163138aa, -477237683, -1325724082];\r\n        this.v = new Array(8);\r\n        this.v_ = new Array(8);\r\n        this.X0 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n        this.X = new Array(68);\r\n        this.xOff = 0;\r\n        this.T_00_15 = 0x79cc4519;\r\n        this.T_16_63 = 0x7a879d8a;\r\n        if (arguments.length > 0) {\r\n            this.initDigest(arguments[0])\r\n        } else {\r\n            this.init()\r\n        }\r\n    }\r\n\r\n    init() {\r\n        this.xBuf = new Array(4);\r\n        this.reset()\r\n    }\r\n\r\n    initDigest(t) {\r\n        this.xBuf = [].concat(t.xBuf);\r\n        this.xBufOff = t.xBufOff;\r\n        this.byteCount = t.byteCount;\r\n        copyArray(t.X, 0, this.X, 0, t.X.length);\r\n        this.xOff = t.xOff;\r\n        copyArray(t.v, 0, this.v, 0, t.v.length);\r\n    }\r\n\r\n    getDigestSize() {\r\n        return this.DIGEST_LENGTH\r\n    }\r\n\r\n    reset() {\r\n        this.byteCount = 0;\r\n        this.xBufOff = 0;\r\n        for (let elem in this.xBuf) this.xBuf[elem] = null;\r\n        copyArray(this.v0, 0, this.v, 0, this.v0.length);\r\n        this.xOff = 0;\r\n        copyArray(this.X0, 0, this.X, 0, this.X0.length);\r\n    }\r\n\r\n    processBlock() {\r\n        let i;\r\n        let ww = this.X;\r\n        let ww_ = new Array(64);\r\n        for (i = 16; i < 68; i++) {\r\n            ww[i] = this.p1(ww[i - 16] ^ ww[i - 9] ^ (this.rotate(ww[i - 3], 15))) ^ (this.rotate(ww[i - 13], 7)) ^ ww[\r\n                i - 6];\r\n        }\r\n        for (i = 0; i < 64; i++) {\r\n            ww_[i] = ww[i] ^ ww[i + 4];\r\n        }\r\n        let vv = this.v;\r\n        let vv_ = this.v_;\r\n        copyArray(vv, 0, vv_, 0, this.v0.length);\r\n        let SS1, SS2, TT1, TT2, aaa;\r\n        for (i = 0; i < 16; i++) {\r\n            aaa = this.rotate(vv_[0], 12);\r\n            SS1 = Int32.parse(Int32.parse(aaa + vv_[4]) + this.rotate(this.T_00_15, i));\r\n            SS1 = this.rotate(SS1, 7);\r\n            SS2 = SS1 ^ aaa;\r\n            TT1 = Int32.parse(Int32.parse(this.ff_00_15(vv_[0], vv_[1], vv_[2]) + vv_[3]) + SS2) + ww_[i];\r\n            TT2 = Int32.parse(Int32.parse(this.gg_00_15(vv_[4], vv_[5], vv_[6]) + vv_[7]) + SS1) + ww[i];\r\n            vv_[3] = vv_[2];\r\n            vv_[2] = this.rotate(vv_[1], 9);\r\n            vv_[1] = vv_[0];\r\n            vv_[0] = TT1;\r\n            vv_[7] = vv_[6];\r\n            vv_[6] = this.rotate(vv_[5], 19);\r\n            vv_[5] = vv_[4];\r\n            vv_[4] = this.p0(TT2);\r\n        }\r\n        for (i = 16; i < 64; i++) {\r\n            aaa = this.rotate(vv_[0], 12);\r\n            SS1 = Int32.parse(Int32.parse(aaa + vv_[4]) + this.rotate(this.T_16_63, i));\r\n            SS1 = this.rotate(SS1, 7);\r\n            SS2 = SS1 ^ aaa;\r\n            TT1 = Int32.parse(Int32.parse(this.ff_16_63(vv_[0], vv_[1], vv_[2]) + vv_[3]) + SS2) + ww_[i];\r\n            TT2 = Int32.parse(Int32.parse(this.gg_16_63(vv_[4], vv_[5], vv_[6]) + vv_[7]) + SS1) + ww[i];\r\n            vv_[3] = vv_[2];\r\n            vv_[2] = this.rotate(vv_[1], 9);\r\n            vv_[1] = vv_[0];\r\n            vv_[0] = TT1;\r\n            vv_[7] = vv_[6];\r\n            vv_[6] = this.rotate(vv_[5], 19);\r\n            vv_[5] = vv_[4];\r\n            vv_[4] = this.p0(TT2);\r\n        }\r\n        for (i = 0; i < 8; i++) {\r\n            vv[i] ^= Int32.parse(vv_[i]);\r\n        }\r\n        this.xOff = 0;\r\n        copyArray(this.X0, 0, this.X, 0, this.X0.length);\r\n    }\r\n\r\n    processWord(in_Renamed, inOff) {\r\n        let n = in_Renamed[inOff] << 24;\r\n        n |= (in_Renamed[++inOff] & 0xff) << 16;\r\n        n |= (in_Renamed[++inOff] & 0xff) << 8;\r\n        n |= (in_Renamed[++inOff] & 0xff);\r\n        this.X[this.xOff] = n;\r\n        if (++this.xOff == 16) {\r\n            this.processBlock();\r\n        }\r\n    }\r\n\r\n    processLength(bitLength) {\r\n        if (this.xOff > 14) {\r\n            this.processBlock();\r\n        }\r\n        this.X[14] = (this.urShiftLong(bitLength, 32));\r\n        this.X[15] = (bitLength & (0xffffffff))\r\n    }\r\n\r\n    intToBigEndian(n, bs, off) {\r\n        bs[off] = Int32.parseByte(this.urShift(n, 24)) & 0xff;\r\n        bs[++off] = Int32.parseByte(this.urShift(n, 16)) & 0xff;\r\n        bs[++off] = Int32.parseByte(this.urShift(n, 8)) & 0xff;\r\n        bs[++off] = Int32.parseByte(n) & 0xff;\r\n    }\r\n\r\n    doFinal(out_Renamed, outOff) {\r\n        this.finish();\r\n        for (let i = 0; i < 8; i++) {\r\n            this.intToBigEndian(this.v[i], out_Renamed, outOff + i * 4);\r\n        }\r\n        this.reset();\r\n        return this.DIGEST_LENGTH;\r\n    }\r\n\r\n    update(input) {\r\n        this.xBuf[this.xBufOff++] = input;\r\n        if (this.xBufOff == this.xBuf.length) {\r\n            this.processWord(this.xBuf, 0);\r\n            this.xBufOff = 0;\r\n        }\r\n        this.byteCount++;\r\n    }\r\n\r\n    blockUpdate(input, inOff, length) {\r\n        while ((this.xBufOff != 0) && (length > 0)) {\r\n            this.update(input[inOff]);\r\n            inOff++;\r\n            length--;\r\n        }\r\n        while (length > this.xBuf.length) {\r\n            this.processWord(input, inOff);\r\n            inOff += this.xBuf.length;\r\n            length -= this.xBuf.length;\r\n            this.byteCount += this.xBuf.length;\r\n        }\r\n        while (length > 0) {\r\n            this.update(input[inOff]);\r\n            inOff++;\r\n            length--;\r\n        }\r\n    }\r\n\r\n    finish() {\r\n        let bitLength = (this.byteCount << 3);\r\n        this.update((128));\r\n        while (this.xBufOff != 0) this.update((0));\r\n        this.processLength(bitLength);\r\n        this.processBlock();\r\n    }\r\n\r\n    rotate(x, n) {\r\n        return (x << n) | (this.urShift(x, (32 - n)));\r\n    }\r\n\r\n    p0(X) {\r\n        return ((X) ^ this.rotate((X), 9) ^ this.rotate((X), 17));\r\n    }\r\n\r\n    p1(X) {\r\n        return ((X) ^ this.rotate((X), 15) ^ this.rotate((X), 23));\r\n    }\r\n\r\n    ff_00_15(X, Y, Z) {\r\n        return (X ^ Y ^ Z);\r\n    }\r\n\r\n    ff_16_63(X, Y, Z) {\r\n        return ((X & Y) | (X & Z) | (Y & Z));\r\n    }\r\n\r\n    gg_00_15(X, Y, Z) {\r\n        return (X ^ Y ^ Z);\r\n    }\r\n\r\n    gg_16_63(X, Y, Z) {\r\n        return ((X & Y) | (~X & Z));\r\n    }\r\n\r\n    urShift(number, bits) {\r\n        if (number > Int32.maxValue || number < Int32.minValue) {\r\n            number = Int32.parse(number);\r\n        }\r\n        if (number >= 0) {\r\n            return number >> bits;\r\n        } else {\r\n            return (number >> bits) + (2 << ~bits);\r\n        }\r\n    }\r\n\r\n    urShiftLong(number, bits) {\r\n        let returnV;\r\n        let big = new BigInteger();\r\n        big.fromInt(number);\r\n        if (big.signum() >= 0) {\r\n            returnV = big.shiftRight(bits).intValue();\r\n        } else {\r\n            let bigAdd = new BigInteger();\r\n            bigAdd.fromInt(2);\r\n            let shiftLeftBits = ~bits;\r\n            let shiftLeftNumber = '';\r\n            if (shiftLeftBits < 0) {\r\n                let shiftRightBits = 64 + shiftLeftBits;\r\n                for (let i = 0; i < shiftRightBits; i++) {\r\n                    shiftLeftNumber += '0';\r\n                }\r\n                let shiftLeftNumberBigAdd = new BigInteger();\r\n                shiftLeftNumberBigAdd.fromInt(number >> bits);\r\n                let shiftLeftNumberBig = new BigInteger(\"10\" + shiftLeftNumber, 2);\r\n                shiftLeftNumber = shiftLeftNumberBig.toRadix(10);\r\n                let r = shiftLeftNumberBig.add(shiftLeftNumberBigAdd);\r\n                returnV = r.toRadix(10);\r\n            } else {\r\n                shiftLeftNumber = bigAdd.shiftLeft((~bits)).intValue();\r\n                returnV = (number >> bits) + shiftLeftNumber;\r\n            }\r\n        }\r\n        return returnV;\r\n    }\r\n\r\n    getZ(g, publicKey) {\r\n        let userId = _.parseUtf8StringToHex('1234567812345678');\r\n        let len = userId.length * 4;\r\n        this.update((len >> 8 & 0x00ff));\r\n        this.update((len & 0x00ff));\r\n        let userIdWords = _.hexToArray(userId);\r\n        this.blockUpdate(userIdWords, 0, userIdWords.length);\r\n        let aWords = _.hexToArray(g.curve.a.toBigInteger().toRadix(16));\r\n        let bWords = _.hexToArray(g.curve.b.toBigInteger().toRadix(16));\r\n        let gxWords = _.hexToArray(g.getX().toBigInteger().toRadix(16));\r\n        let gyWords = _.hexToArray(g.getY().toBigInteger().toRadix(16));\r\n        let pxWords = _.hexToArray(publicKey.substr(0, 64));\r\n        let pyWords = _.hexToArray(publicKey.substr(64, 64));\r\n        this.blockUpdate(aWords, 0, aWords.length);\r\n        this.blockUpdate(bWords, 0, bWords.length);\r\n        this.blockUpdate(gxWords, 0, gxWords.length);\r\n        this.blockUpdate(gyWords, 0, gyWords.length);\r\n        this.blockUpdate(pxWords, 0, pxWords.length);\r\n        this.blockUpdate(pyWords, 0, pyWords.length);\r\n        let md = new Array(this.getDigestSize());\r\n        this.doFinal(md, 0);\r\n        return md;\r\n    }\r\n}\r\n\r\nmodule.exports = SM3Digest;\r\n","const { BigInteger, SecureRandom } = require('jsbn');\nconst { ECCurveFp } = require ('./ec');\n\nlet rng = new SecureRandom();\nlet { curve, G, n } = generateEcparam();\n\n/**\n * 获取公共椭圆曲线\n */\nfunction getGlobalCurve() {\n    return curve;\n}\n\n/**\n * 生成ecparam\n */\nfunction generateEcparam() {\n    // 椭圆曲线\n    let p = new BigInteger('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF', 16);\n    let a = new BigInteger('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC', 16);\n    let b = new BigInteger('28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93', 16);\n    let curve = new ECCurveFp(p, a, b);\n\n    // 基点\n    let gxHex = '32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7';\n    let gyHex = 'BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0';\n    let G = curve.decodePointHex('04' + gxHex + gyHex);\n\n    let n = new BigInteger('FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123', 16);\n\n    return { curve, G, n };\n}\n\n/**\n * 生成密钥对\n */\nfunction generateKeyPairHex() {\n    let d = new BigInteger(n.bitLength(), rng).mod(n.subtract(BigInteger.ONE)).add(BigInteger.ONE); // 随机数\n    let privateKey = leftPad(d.toString(16), 64);\n\n    let P = G.multiply(d); // P = dG，p 为公钥，d 为私钥\n    let Px = leftPad(P.getX().toBigInteger().toString(16), 64);\n    let Py = leftPad(P.getY().toBigInteger().toString(16), 64);\n    let publicKey = '04' + Px + Py;\n\n    return { privateKey, publicKey };\n}\n\n/**\n * 解析utf8字符串到16进制\n */\nfunction parseUtf8StringToHex(input) {\n    input = unescape(encodeURIComponent(input));\n\n    let length = input.length;\n\n    // 转换到字数组\n    let words = [];\n    for (let i = 0; i < length; i++) {\n        words[i >>> 2] |= (input.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    // 转换到16进制\n    let hexChars = [];\n    for (let i = 0; i < length; i++) {\n        let bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        hexChars.push((bite >>> 4).toString(16));\n        hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n}\n\n/**\n * 解析arrayBuffer到16进制字符串\n */\nfunction parseArrayBufferToHex(input) {\n    return Array.prototype.map.call(new Uint8Array(input), x => ('00' + x.toString(16)).slice(-2)).join('');\n}\n\n/**\n * 补全16进制字符串\n */\nfunction leftPad(input, num) {\n    if (input.length >= num) return input;\n\n    return (new Array(num - input.length + 1)).join('0') + input\n}\n\n/**\n * 转成16进制串\n */\nfunction arrayToHex(arr) {\n    let words = [];\n    let j = 0;\n    for (let i = 0; i < arr.length * 2; i += 2) {\n        words[i >>> 3] |= parseInt(arr[j], 10) << (24 - (i % 8) * 4);\n        j++;\n    }\n    \n    // 转换到16进制\n    let hexChars = [];\n    for (let i = 0; i < arr.length; i++) {\n        let bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        hexChars.push((bite >>> 4).toString(16));\n        hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n}\n\n/**\n * 转成utf8串\n */\nfunction arrayToUtf8(arr) {\n    let words = [];\n    let j = 0;\n    for (let i = 0; i < arr.length * 2; i += 2) {\n        words[i >>> 3] |= parseInt(arr[j], 10) << (24 - (i % 8) * 4);\n        j++\n    }\n\n    try {\n        let latin1Chars = [];\n\n        for (let i = 0; i < arr.length; i++) {\n            let bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            latin1Chars.push(String.fromCharCode(bite));\n        }\n\n        return decodeURIComponent(escape(latin1Chars.join('')));\n    } catch (e) {\n        throw new Error('Malformed UTF-8 data');\n    }\n}\n\n/**\n * 转成ascii码数组\n */\nfunction hexToArray(hexStr) {\n    let words = [];\n    let hexStrLength = hexStr.length;\n\n    if (hexStrLength % 2 !== 0) {\n        hexStr = leftPad(hexStr, hexStrLength + 1);\n    }\n\n    hexStrLength = hexStr.length;\n\n    for (let i = 0; i < hexStrLength; i += 2) {\n        words.push(parseInt(hexStr.substr(i, 2), 16));\n    }\n    return words\n}\n\nmodule.exports = {\n    getGlobalCurve,\n    generateEcparam,\n    generateKeyPairHex,\n    parseUtf8StringToHex,\n    parseArrayBufferToHex,\n    leftPad,\n    arrayToHex,\n    arrayToUtf8,\n    hexToArray,\n};\n","const { BigInteger } = require('jsbn');\r\n\r\n/**\r\n * thanks for Tom Wu : http://www-cs-students.stanford.edu/~tjw/jsbn/\r\n *\r\n * Basic Javascript Elliptic Curve implementation\r\n * Ported loosely from BouncyCastle's Java EC code\r\n * Only Fp curves implemented for now\r\n */\r\n\r\nconst THREE = new BigInteger('3');\r\n\r\n/**\r\n * 椭圆曲线域元素\r\n */\r\nclass ECFieldElementFp {\r\n    constructor(q, x) {\r\n        this.x = x;\r\n        this.q = q;\r\n        // TODO if (x.compareTo(q) >= 0) error\r\n    }\r\n\r\n    /**\r\n     * 判断相等\r\n     */\r\n    equals(other) {\r\n        if (other === this) return true;\r\n        return (this.q.equals(other.q) && this.x.equals(other.x));\r\n    }\r\n\r\n    /**\r\n     * 返回具体数值\r\n     */\r\n    toBigInteger() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * 取反\r\n     */\r\n    negate() {\r\n        return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));\r\n    }\r\n\r\n    /**\r\n     * 相加\r\n     */\r\n    add(b) {\r\n        return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));\r\n    }\r\n\r\n    /**\r\n     * 相减\r\n     */\r\n    subtract(b) {\r\n        return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));\r\n    }\r\n\r\n    /**\r\n     * 相乘\r\n     */\r\n    multiply(b) {\r\n        return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));\r\n    }\r\n\r\n    /**\r\n     * 相除\r\n     */\r\n    divide(b) {\r\n        return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));\r\n    }\r\n\r\n    /**\r\n     * 平方\r\n     */\r\n    square() {\r\n        return new ECFieldElementFp(this.q, this.x.square().mod(this.q));\r\n    }\r\n}\r\n\r\nclass ECPointFp {\r\n    constructor(curve, x, y, z) {\r\n        this.curve = curve;\r\n        this.x = x;\r\n        this.y = y;\r\n        // 标准射影坐标系：zinv == null 或 z * zinv == 1\r\n        this.z = z === undefined ? BigInteger.ONE : z;\r\n        this.zinv = null;\r\n        //TODO: compression flag\r\n    }\r\n\r\n    getX() {\r\n        if (this.zinv === null) this.zinv = this.z.modInverse(this.curve.q);\r\n\r\n        return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q));\r\n    }\r\n\r\n    getY() {\r\n        if (this.zinv === null) this.zinv = this.z.modInverse(this.curve.q);\r\n\r\n        return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q));\r\n    }\r\n\r\n    /**\r\n     * 判断相等\r\n     */\r\n    equals(other) {\r\n        if (other === this) return true;\r\n        if (this.isInfinity()) return other.isInfinity();\r\n        if (other.isInfinity()) return this.isInfinity();\r\n\r\n        // u = y2 * z1 - y1 * z2\r\n        let u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);\r\n        if (!u.equals(BigInteger.ZERO)) return false;\r\n\r\n        // v = x2 * z1 - x1 * z2\r\n        let v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);\r\n        return v.equals(BigInteger.ZERO);\r\n    }\r\n\r\n    /**\r\n     * 是否是无穷远点\r\n     */\r\n    isInfinity() {\r\n        if ((this.x === null) && (this.y === null)) return true;\r\n        return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);\r\n    }\r\n\r\n    /**\r\n     * 取反，x 轴对称点\r\n     */\r\n    negate() {\r\n        return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);\r\n    }\r\n\r\n    /**\r\n     * 相加\r\n     *\r\n     * 标准射影坐标系：\r\n     * \r\n     * λ1 = x1 * z2\r\n     * λ2 = x2 * z1\r\n     * λ3 = λ1 − λ2\r\n     * λ4 = y1 * z2\r\n     * λ5 = y2 * z1\r\n     * λ6 = λ4 − λ5\r\n     * λ7 = λ1 + λ2\r\n     * λ8 = z1 * z2\r\n     * λ9 = λ3^2\r\n     * λ10 = λ3 * λ9\r\n     * λ11 = λ8 * λ6^2 − λ7 * λ9\r\n     * x3 = λ3 * λ11\r\n     * y3 = λ6 * (λ9 * λ1 − λ11) − λ4 * λ10\r\n     * z3 = λ10 * λ8\r\n     */\r\n    add(b) {\r\n        if (this.isInfinity()) return b;\r\n        if (b.isInfinity()) return this;\r\n\r\n        let x1 = this.x.toBigInteger();\r\n        let y1 = this.y.toBigInteger();\r\n        let z1 = this.z;\r\n        let x2 = b.x.toBigInteger();\r\n        let y2 = b.y.toBigInteger();\r\n        let z2 = b.z;\r\n        let q = this.curve.q;\r\n        \r\n        let w1 = x1.multiply(z2).mod(q);\r\n        let w2 = x2.multiply(z1).mod(q);\r\n        let w3 = w1.subtract(w2);\r\n        let w4 = y1.multiply(z2).mod(q);\r\n        let w5 = y2.multiply(z1).mod(q);\r\n        let w6 = w4.subtract(w5);\r\n\r\n        if (BigInteger.ZERO.equals(w3)) {\r\n            if (BigInteger.ZERO.equals(w6)) {\r\n                return this.twice(); // this == b，计算自加\r\n            }\r\n            return this.curve.infinity; // this == -b，则返回无穷远点\r\n        }\r\n\r\n        let w7 = w1.add(w2);\r\n        let w8 = z1.multiply(z2).mod(q);\r\n        let w9 = w3.square().mod(q);\r\n        let w10 = w3.multiply(w9).mod(q);\r\n        let w11 = w8.multiply(w6.square()).subtract(w7.multiply(w9)).mod(q);\r\n\r\n        let x3 = w3.multiply(w11).mod(q);\r\n        let y3 = w6.multiply(w9.multiply(w1).subtract(w11)).subtract(w4.multiply(w10)).mod(q);\r\n        let z3 = w10.multiply(w8).mod(q);\r\n\r\n        return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\r\n    }\r\n\r\n    /**\r\n     * 自加\r\n     *\r\n     * 标准射影坐标系：\r\n     * \r\n     * λ1 = 3 * x1^2 + a * z1^2\r\n     * λ2 = 2 * y1 * z1\r\n     * λ3 = y1^2\r\n     * λ4 = λ3 * x1 * z1\r\n     * λ5 = λ2^2\r\n     * λ6 = λ1^2 − 8 * λ4\r\n     * x3 = λ2 * λ6\r\n     * y3 = λ1 * (4 * λ4 − λ6) − 2 * λ5 * λ3\r\n     * z3 = λ2 * λ5\r\n     */\r\n    twice() {\r\n        if (this.isInfinity()) return this;\r\n        if (!this.y.toBigInteger().signum()) return this.curve.infinity;\r\n\r\n        let x1 = this.x.toBigInteger();\r\n        let y1 = this.y.toBigInteger();\r\n        let z1 = this.z;\r\n        let q = this.curve.q;\r\n        let a = this.curve.a.toBigInteger();\r\n\r\n        let w1 = x1.square().multiply(THREE).add(a.multiply(z1.square())).mod(q);\r\n        let w2 = y1.shiftLeft(1).multiply(z1).mod(q);\r\n        let w3 = y1.square().mod(q);\r\n        let w4 = w3.multiply(x1).multiply(z1).mod(q);\r\n        let w5 = w2.square().mod(q);\r\n        let w6 = w1.square().subtract(w4.shiftLeft(3)).mod(q);\r\n\r\n        let x3 = w2.multiply(w6).mod(q);\r\n        let y3 = w1.multiply(w4.shiftLeft(2).subtract(w6)).subtract(w5.shiftLeft(1).multiply(w3)).mod(q);\r\n        let z3 = w2.multiply(w5).mod(q);\r\n\r\n        return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\r\n    }\r\n\r\n    /**\r\n     * 倍点计算\r\n     */\r\n    multiply(k) {\r\n        if (this.isInfinity()) return this;\r\n        if (!k.signum()) return this.curve.infinity;\r\n\r\n        // 使用加减法\r\n        let k3 = k.multiply(THREE);\r\n        let neg = this.negate();\r\n        let Q = this;\r\n\r\n        for (let i = k3.bitLength() - 2; i > 0; i--) {\r\n            Q = Q.twice();\r\n\r\n            let k3Bit = k3.testBit(i);\r\n            let kBit = k.testBit(i);\r\n\r\n            if (k3Bit !== kBit) {\r\n                Q = Q.add(k3Bit ? this : neg);\r\n            }\r\n        }\r\n\r\n        return Q;\r\n    }\r\n}\r\n\r\n/**\r\n * 椭圆曲线 y^2 = x^3 + ax + b\r\n */\r\nclass ECCurveFp {\r\n    constructor(q, a, b) {\r\n        this.q = q;\r\n        this.a = this.fromBigInteger(a);\r\n        this.b = this.fromBigInteger(b);\r\n        this.infinity = new ECPointFp(this, null, null); // 无穷远点\r\n    }\r\n\r\n    /**\r\n     * 判断两个椭圆曲线是否相等\r\n     */\r\n    equals(other) {\r\n        if (other === this) return true;\r\n        return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));\r\n    }\r\n\r\n    /**\r\n     * 生成椭圆曲线域元素\r\n     */\r\n    fromBigInteger(x) {\r\n        return new ECFieldElementFp(this.q, x);\r\n    }\r\n\r\n    /**\r\n     * 解析 16 进制串为椭圆曲线点\r\n     */\r\n    decodePointHex(s) {\r\n        switch (parseInt(s.substr(0, 2), 16)) {\r\n            // 第一个字节\r\n            case 0:\r\n                return this.infinity;\r\n            case 2:\r\n            case 3:\r\n                // 不支持的压缩方式\r\n                return null;\r\n            case 4:\r\n            case 6:\r\n            case 7:\r\n                let len = (s.length - 2) / 2;\r\n                let xHex = s.substr(2, len);\r\n                let yHex = s.substr(len + 2, len);\r\n\r\n                return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));\r\n            default:\r\n                // 不支持\r\n                return null;\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    ECPointFp,\r\n    ECCurveFp,\r\n};\r\n","const { BigInteger } = require('jsbn');\r\nconst SM3Digest = require('./sm3');\r\nconst _ = require('./utils');\r\n\r\nclass SM2Cipher {\r\n    constructor() {\r\n        this.ct = 1;\r\n        this.p2 = null;\r\n        this.sm3keybase = null;\r\n        this.sm3c3 = null;\r\n        this.key = new Array(32);\r\n        this.keyOff = 0;\r\n    }\r\n\r\n    reset() {\r\n        this.sm3keybase = new SM3Digest();\r\n        this.sm3c3 = new SM3Digest();\r\n        let xWords = _.hexToArray(this.p2.getX().toBigInteger().toRadix(16));\r\n        let yWords = _.hexToArray(this.p2.getY().toBigInteger().toRadix(16));\r\n        this.sm3keybase.blockUpdate(xWords, 0, xWords.length);\r\n        this.sm3c3.blockUpdate(xWords, 0, xWords.length);\r\n        this.sm3keybase.blockUpdate(yWords, 0, yWords.length);\r\n        this.ct = 1;\r\n        this.nextKey();\r\n    }\r\n\r\n    nextKey() {\r\n        let sm3keycur = new SM3Digest(this.sm3keybase);\r\n        sm3keycur.update((this.ct >> 24 & 0x00ff));\r\n        sm3keycur.update((this.ct >> 16 & 0x00ff));\r\n        sm3keycur.update((this.ct >> 8 & 0x00ff));\r\n        sm3keycur.update((this.ct & 0x00ff));\r\n        sm3keycur.doFinal(this.key, 0);\r\n        this.keyOff = 0;\r\n        this.ct++;\r\n    }\r\n\r\n    initEncipher(userKey) {\r\n        let keypair = _.generateKeyPairHex();\r\n        let k = new BigInteger(keypair.privateKey, 16);\r\n        let publicKey = keypair.publicKey;\r\n\r\n        this.p2 = userKey.multiply(k); // [k](Pb)\r\n        this.reset();\r\n\r\n        if (publicKey.length > 128) {\r\n          publicKey = publicKey.substr(publicKey.length - 128);\r\n        }\r\n\r\n        return publicKey;\r\n    }\r\n\r\n    encryptBlock(data) {\r\n        this.sm3c3.blockUpdate(data, 0, data.length);\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (this.keyOff === this.key.length) {\r\n                this.nextKey();\r\n            }\r\n            data[i] ^= this.key[this.keyOff++] & 0xff;\r\n        }\r\n    }\r\n\r\n    initDecipher(userD, c1) {\r\n        this.p2 = c1.multiply(userD);\r\n        this.reset();\r\n    }\r\n\r\n    decryptBlock(data) {\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (this.keyOff === this.key.length) {\r\n                this.nextKey();\r\n            }\r\n            data[i] ^= this.key[this.keyOff++] & 0xff;\r\n        }\r\n        this.sm3c3.blockUpdate(data, 0, data.length);\r\n    }\r\n\r\n    doFinal(c3) {\r\n        let yWords = _.hexToArray(this.p2.getY().toBigInteger().toRadix(16));\r\n        this.sm3c3.blockUpdate(yWords, 0, yWords.length);\r\n        this.sm3c3.doFinal(c3, 0);\r\n        this.reset();\r\n    }\r\n    \r\n    createPoint(x, y) {\r\n        let publicKey = '04' + x + y;\r\n        let point = _.getGlobalCurve().decodePointHex(publicKey);\r\n        return point;\r\n    }\r\n}\r\n\r\nmodule.exports = SM2Cipher;\r\n","/**\n * 左补0到指定长度\n */\nfunction leftPad(input, num) {\n    if (input.length >= num) return input;\n\n    return (new Array(num - input.length + 1)).join('0') + input\n}\n\n/**\n * 二进制转化为十六进制\n */\nfunction binary2hex(binary) {\n    const binaryLength = 8;\n    let hex = '';\n    for (let i = 0; i < binary.length / binaryLength; i++) {\n        hex += leftPad(parseInt(binary.substr(i * binaryLength, binaryLength), 2).toString(16), 2);\n    }\n    return hex;\n}\n\n/**\n * 十六进制转化为二进制\n */\nfunction hex2binary(hex) {\n    const hexLength = 2;\n    let binary = '';\n    for (let i = 0; i < hex.length / hexLength; i++) {\n        binary += leftPad(parseInt(hex.substr(i * hexLength, hexLength), 16).toString(2), 8);\n    }\n    return binary;\n}\n\n/**\n * 普通字符串转化为二进制\n */\nfunction str2binary(str) {\n    let binary = '';\n    for (const ch of str) {\n        binary += leftPad(ch.codePointAt(0).toString(2), 8);\n    }\n    return binary;\n}\n\n/**\n * 循环左移\n */\nfunction rol(str, n) {\n    return str.substring(n % str.length) + str.substr(0, n % str.length);\n}\n\n/**\n * 二进制运算\n */\nfunction binaryCal(x, y, method) {\n    const a = x || '';\n    const b = y || '';\n    const result = [];\n    let prevResult;\n\n    for (let i = a.length - 1; i >= 0; i--) { // 大端\n        prevResult = method(a[i], b[i], prevResult);\n        result[i] = prevResult[0];\n    }\n    return result.join('');\n}\n\n/**\n * 二进制异或运算\n */\nfunction xor(x, y) {\n    return binaryCal(x, y, (a, b) => [(a === b ? '0' : '1')]);\n}\n\n/**\n * 二进制与运算\n */\nfunction and(x, y) {\n    return binaryCal(x, y, (a, b) => [(a === '1' && b === '1' ? '1' : '0')]);\n}\n\n/**\n * 二进制或运算\n */\nfunction or(x, y) {\n    return binaryCal(x, y, (a, b) => [(a === '1' || b === '1' ? '1' : '0')]); // a === '0' && b === '0' ? '0' : '1'\n}\n\n/**\n * 二进制与运算\n */\nfunction add(x, y) {\n    const result = binaryCal(x, y, (a, b, prevResult) => {\n        const carry = prevResult ? prevResult[1] : '0' || '0';\n\n        // a,b不等时,carry不变，结果与carry相反\n        // a,b相等时，结果等于原carry，新carry等于a\n        if (a !== b) return [carry === '0' ? '1' : '0', carry];\n\n        return [carry, a];\n    });\n    \n    return result;\n}\n\n/**\n * 二进制非运算\n */\nfunction not(x) {\n    return binaryCal(x, undefined, a => [a === '1' ? '0' : '1']);\n}\n\nfunction calMulti(method) {\n    return (...arr) => arr.reduce((prev, curr) => method(prev, curr));\n}\n\n/**\n * 压缩函数中的置换函数 P1(X) = X xor (X <<< 9) xor (X <<< 17)\n */\nfunction P0(X) {\n    return calMulti(xor)(X, rol(X, 9), rol(X, 17));\n}\n\n/**\n * 消息扩展中的置换函数 P1(X) = X xor (X <<< 15) xor (X <<< 23)\n */\nfunction P1(X) {\n    return calMulti(xor)(X, rol(X, 15), rol(X, 23));\n}\n\nfunction FF(X, Y, Z, j) {\n    return j >= 0 && j <= 15 ? calMulti(xor)(X, Y, Z) : calMulti(or)(and(X, Y), and(X, Z), and(Y, Z));\n}\n\nfunction GG(X, Y, Z, j) {\n    return j >= 0 && j <= 15 ? calMulti(xor)(X, Y, Z) : or(and(X, Y), and(not(X), Z));\n}\n\nfunction T(j) {\n    return j >= 0 && j <= 15 ? hex2binary('79cc4519') : hex2binary('7a879d8a');\n}\n\n/**\n * 压缩函数\n */\nfunction CF(V, Bi) {\n    // 消息扩展\n    const wordLength = 32;\n    const W = [];\n    const M = []; // W'\n\n    // 将消息分组B划分为16个字W0， W1，…… ，W15 （字为长度为32的比特串）\n    for (let i = 0; i < 16; i++) {\n        W.push(Bi.substr(i * wordLength, wordLength));\n    }\n\n    // W[j] <- P1(W[j−16] xor W[j−9] xor (W[j−3] <<< 15)) xor (W[j−13] <<< 7) xor W[j−6]\n    for (let j = 16; j < 68; j++) {\n        W.push(calMulti(xor)(\n            P1(calMulti(xor)(W[j - 16], W[j - 9], rol(W[j - 3], 15))),\n            rol(W[j - 13], 7),\n            W[j - 6]\n        ));\n    }\n\n    // W′[j] = W[j] xor W[j+4]\n    for (let j = 0; j < 64; j++) {\n        M.push(xor(W[j], W[j + 4]));\n    }\n\n    // 压缩\n    const wordRegister = []; // 字寄存器\n    for (let j = 0; j < 8; j++) {\n        wordRegister.push(V.substr(j * wordLength, wordLength));\n    }\n\n    let A = wordRegister[0];\n    let B = wordRegister[1];\n    let C = wordRegister[2];\n    let D = wordRegister[3];\n    let E = wordRegister[4];\n    let F = wordRegister[5];\n    let G = wordRegister[6];\n    let H = wordRegister[7];\n\n    // 中间变量\n    let SS1;\n    let SS2;\n    let TT1;\n    let TT2;\n    for (let j = 0; j < 64; j++) {\n        SS1 = rol(calMulti(add)(rol(A, 12), E, rol(T(j), j)), 7);\n        SS2 = xor(SS1, rol(A, 12));\n\n        TT1 = calMulti(add)(FF(A, B, C, j), D, SS2, M[j]);\n        TT2 = calMulti(add)(GG(E, F, G, j), H, SS1, W[j]);\n\n        D = C;\n        C = rol(B, 9);\n        B = A;\n        A = TT1;\n        H = G;\n        G = rol(F, 19);\n        F = E;\n        E = P0(TT2);\n    }\n\n    return xor([A, B, C, D, E, F, G, H].join(''), V);\n}\n\nmodule.exports = function(str) {\n    const binary = str2binary(str);\n\n    // 填充\n    const len = binary.length;\n\n    // k是满足len + 1 + k = 448mod512的最小的非负整数\n    let k = len % 512;\n\n    // 如果 448 <= (512 % len) < 512，需要多补充 (len % 448) 比特'0'以满足总比特长度为512的倍数\n    k = k >= 448 ? 512 - (k % 448) - 1 : 448 - k - 1;\n\n    const m = `${binary}1${leftPad('', k)}${leftPad(len.toString(2), 64)}`.toString(); // k个0\n\n    // 迭代压缩\n    const n = (len + k + 65) / 512;\n\n    let V = hex2binary('7380166f4914b2b9172442d7da8a0600a96f30bc163138aae38dee4db0fb0e4e');\n    for (let i = 0; i <= n - 1; i++) {\n        const B = m.substr(512 * i, 512);\n        V = CF(V, B);\n    }\n    return binary2hex(V);\n};\n","const DECRYPT = 0;\r\nconst ROUND = 32;\r\nconst BLOCK = 16;\r\n\r\nconst Sbox = [\r\n    0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05,\r\n    0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99,\r\n    0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62,\r\n    0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6,\r\n    0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8,\r\n    0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35,\r\n    0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87,\r\n    0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e,\r\n    0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1,\r\n    0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3,\r\n    0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f,\r\n    0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51,\r\n    0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8,\r\n    0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0,\r\n    0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84,\r\n    0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48\r\n];\r\n\r\nconst CK = [\r\n    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,\r\n    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,\r\n    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,\r\n    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,\r\n    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,\r\n    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,\r\n    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,\r\n    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279\r\n];\r\n\r\nfunction rotl(x, y) {\r\n    return x << y | x >>> (32 - y);\r\n}\r\n\r\nfunction byteSub(a) {\r\n    return (Sbox[a >>> 24 & 0xFF] & 0xFF) << 24 | (Sbox[a >>> 16 & 0xFF] & 0xFF) << 16 | (Sbox[a >>> 8 & 0xFF] & 0xFF) << 8 | (Sbox[a & 0xFF] & 0xFF);\r\n}\r\n\r\nfunction l1(b) {\r\n    return b ^ rotl(b, 2) ^ rotl(b, 10) ^ rotl(b, 18) ^ rotl(b, 24);\r\n}\r\n\r\nfunction l2(b) {\r\n    return b ^ rotl(b, 13) ^ rotl(b, 23);\r\n}\r\n\r\nfunction sms4Crypt(input, output, roundKey) {\r\n    let r;\r\n    let mid;\r\n    let x = new Array(4);\r\n    let tmp = new Array(4);\r\n    for(let i = 0; i < 4; i++) {\r\n        tmp[0] = input[0 + 4 * i] & 0xff;\r\n        tmp[1] = input[1 + 4 * i] & 0xff;\r\n        tmp[2] = input[2 + 4 * i] & 0xff;\r\n        tmp[3] = input[3 + 4 * i] & 0xff;\r\n        x[i] = tmp[0] << 24 | tmp[1] << 16 | tmp[2] << 8 | tmp[3];\r\n    }\r\n\r\n    for(r = 0; r < 32; r += 4) {\r\n        mid = x[1] ^ x[2] ^ x[3] ^ roundKey[r + 0];\r\n        mid = byteSub(mid);\r\n        x[0] = x[0] ^ l1(mid); // x4\r\n        \r\n        mid = x[2] ^ x[3] ^ x[0] ^ roundKey[r + 1];\r\n        mid = byteSub(mid);\r\n        x[1] = x[1] ^ l1(mid); // x5\r\n        \r\n        mid = x[3] ^ x[0] ^ x[1] ^ roundKey[r + 2];\r\n        mid = byteSub(mid);\r\n        x[2] = x[2] ^ l1(mid); // x6\r\n        \r\n        mid = x[0] ^ x[1] ^ x[2] ^ roundKey[r + 3];\r\n        mid = byteSub(mid);\r\n        x[3] = x[3] ^ l1(mid); // x7\r\n    }\r\n    \r\n    //Reverse\r\n    for(let j = 0; j < 16; j += 4) {\r\n        output[j] = x[3 - j / 4] >>> 24 & 0xff;\r\n        output[j+1] = x[3 - j / 4] >>> 16 & 0xff;\r\n        output[j+2] = x[3 - j / 4] >>> 8 & 0xff;\r\n        output[j+3] = x[3 - j / 4] & 0xff;\r\n    }\r\n}\r\n\r\nfunction sms4KeyExt(key, roundKey, cryptFlag) {\r\n    let r;\r\n    let mid;\r\n    let x = new Array(4);\r\n    let tmp = new Array(4);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        tmp[0] = key[0 + 4 * i] & 0xff;\r\n        tmp[1] = key[1 + 4 * i] & 0xff;\r\n        tmp[2] = key[2 + 4 * i] & 0xff;\r\n        tmp[3] = key[3 + 4 * i] & 0xff;\r\n        x[i] = tmp[0] << 24 | tmp[1] << 16 | tmp[2] << 8 | tmp[3];\r\n    }\r\n\r\n    x[0] ^= 0xa3b1bac6;\r\n    x[1] ^= 0x56aa3350;\r\n    x[2] ^= 0x677d9197;\r\n    x[3] ^= 0xb27022dc;\r\n\r\n    for(r = 0; r < 32; r += 4) {\r\n        mid = x[1] ^ x[2] ^ x[3] ^ CK[r+0];\r\n        mid = byteSub(mid);\r\n        roundKey[r + 0] = x[0] ^= l2(mid); // roundKey0 = K4\r\n        \r\n        mid = x[2] ^ x[3] ^ x[0] ^ CK[r+1];\r\n        mid = byteSub(mid);\r\n        roundKey[r + 1] = x[1] ^= l2(mid); // roundKey1 = K5\r\n        \r\n        mid = x[3] ^ x[0] ^ x[1] ^ CK[r+2];\r\n        mid = byteSub(mid);\r\n        roundKey[r + 2] = x[2] ^= l2(mid); // roundKey2 = K6\r\n        \r\n        mid = x[0] ^ x[1] ^ x[2] ^ CK[r + 3];\r\n        mid = byteSub(mid);\r\n        roundKey[r + 3] = x[3] ^= l2(mid); // roundKey3 = K7\r\n    }\r\n        \r\n    // 解密时轮密钥使用顺序：roundKey31, roundKey30, ..., roundKey0\r\n    if(cryptFlag === DECRYPT) {\r\n        for(r = 0; r < 16; r++) {\r\n            mid = roundKey[r];\r\n            roundKey[r] = roundKey[31 - r];\r\n            roundKey[31 - r] = mid;\r\n        }\r\n    }\r\n}\r\n\r\nfunction sm4(inArray, key, cryptFlag) {\r\n    let outArray = [];\r\n    let point = 0;\r\n    let roundKey = new Array(ROUND); \r\n    sms4KeyExt(key, roundKey, cryptFlag);\r\n\r\n    let input = new Array(16);\r\n    let output = new Array(16);\r\n\r\n    let inLen = inArray.length;\r\n    while (inLen >= BLOCK) {\r\n        input = inArray.slice(point, point + 16);\r\n        sms4Crypt(input, output, roundKey);\r\n        \r\n        for (let i = 0; i < BLOCK; i++) {\r\n            outArray[point + i] = output[i];\r\n        }\r\n\r\n        inLen -= BLOCK;\r\n        point += BLOCK;\r\n    }\r\n\r\n    return outArray;\r\n}\r\n\r\nmodule.exports = {\r\n    encrypt(inArray, key) {\r\n        return sm4(inArray, key, 1);\r\n    },\r\n    decrypt(inArray, key) {\r\n        return sm4(inArray, key, 0);\r\n    }\r\n};\r\n"]}